* 메소드 호출 과정 (헤드퍼스트 디자인패턴 468p 그림 참고)
    1. 클라이언트 객체에서 클라이언트 보조 객체의 doBigThing()을 호출
    2. 클라이언트 보조 객체는 메소드 호출 정보(인자, 메소드 이름 등)를 잘 포장해서 네트워크로 서비스 보조 객체에게 전달
    3. 서비스 보조 객체는 클라이언트 보조 객체로부터 받은 정보를 해석해서 어떤 객체의 어떤 메소드를 호출할지 알아낸 다음 진짜 서비스 객체의 메소드를 호출
    4. 서비스 객체의 메소드 실행이 끝나면 서비스 보조 객체에 어떤 결과가 리턴됌
    5. 서비스 보조 객체는 호출 결과로 리턴된 정보를 포장해서 네트워크로 클라이언트 보조 객체에게 전달
    6. 클라이언트 보조 객체는 리턴된 정보를 해석해서 클라이언트 개체에게 리턴함 /
       클라이언트 객체는 메소드 호출이 어디로 전달되었는지, 어디에서 리턴되었는지 전혀 알 수 없음

*RMI
    - 사용자 대신 클라이언트와 서비스 보조 객체를 만들어 줌.
    - 보조 객체에는 원격 서비스와 똑같은 메소드가 들어있음
    - RMI를 사용하면 네트워킹 및 입출력 관련 코드를 직접 작성하지 않아도 됌
    - 룩업 서비스 제공 ( 클라이언트가 원격 객체를 찾아서 접근할떄 쓸 수 있는 서비스)

    * 로컬 메소드 호출과의 차이점
        - 클라이언트는 로컬 메소드 호출과 똑같은 식으로 메소드를 호출하지만, 실제로는 클라이언트 보조 객체가 네트워크로 호출을 전송해야 하므로
          네트워킹 및 입출력 기능이 반드시 필요함

    * 스텁 => 클라이언트 보조 객체
    * 스켈레톤 => 서비스 보조 객체